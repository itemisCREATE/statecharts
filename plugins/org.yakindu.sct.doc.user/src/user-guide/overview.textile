
p. 

h1(#overview_what_are_state_machines). What is a state machine?

A state machine is a behavior model. It consists of a finite number of states and is therefore also called finite-state machine (FSM). Based on the current state and a given input the machine performs state transitions and produces outputs. There are basic types like Mealy and Moore machines and more complex types like Harel and UML statecharts.

This introduction gives a short overview of the common basis and the differences between state machine types.

!(small)images/simple_moore.png(Simple example as a Moore machine)!

p=. Simple state machine

The basic building blocks of a state machine are states and transitions. A state is a situation of a system depending on previous inputs and causes a reaction on following inputs. One state is marked as the initial state; this is where the execution of the machine starts. A state transition defines when a state is changed from one to another. This can be an input, like pressing a button, and/or a condition that needs to be fulfilled. Depending on the state machine type, states and/or transitions produce outputs.

Consider the simple state machine above. It consists of two states, _Off_ and _On_. _On_ is the initial state here; it is activated when the state machine is executed. The arrows between the states denote the possible state transitions. They define for which input a state change occurs. Here, the active state is changed from _On_ to _Off_ for the input _buttonpressed_, and back again to _On_ for the same input. 

bq. *Please note:* In automata theory an automaton reacts on inputs and produces outputs. There, the terms input and output are usually used for text inputs/outputs. Modern state machines use an extended definition of inputs and outputs. Inputs can be events like a button click or a time trigger while outputs are actions like an operation call or a variable assignment.

In the following, we will extend the simple switch example to explain the differences between Mealy and Moore machines as well as Harel statecharts and UML state machines.


*Moore machines*

In automata theory, there are two basic types of finite-state machines (FSM). One of those is called "_Moore_ machine":https://en.wikipedia.org/wiki/Moore_machine, named after its inventor Edward Moore. Moore machines consist of states and transitions. *States are able to produce outputs*, and the output is determined solely by the current state, not by any input.

We extend the switch example above into a light switch with different brightness levels. The light switch has two buttons, an _ON_ button and an _OFF_ button. Pressing the _ON_ button switches the light on and toggles through the different brightness levels. This behavior is modeled by the state machine below. Pressing a button raises a corresponding event (_ON_pressed_ or _OFF_pressed_) upon which the machine reacts with a state change and corresponding outputs/actions. The output of the state machine is simply the brightness value. As in Moore machines only states produce outputs, we need one dedicated state per brightness level:

!(small)images/overview_moore.png(Light switch example as a Moore machine, modeled with YAKINDU Statechart Tools)!

p=. Light switch example as a Moore machine, modeled with YAKINDU Statechart Tools


*Mealy machines*

In comparison with Moore machines, "_Mealy_ machines":https://en.wikipedia.org/wiki/Mealy_machine *produce outputs only on transitions* and not in states. This often results in state diagrams with fewer states because more logic can be put on transitions. 

In the light switch example we can now merge all _Light On_ states into one and produce the output on a transition. Here we just increment the brightness value each time the transition is taken. We use the modulo expression to ensure the brightness value stays between 1 and 3.

!(small)images/overview_mealy.png(Light switch example as a Mealy machine)!

p=. Light switch example as a Mealy machine

Be aware that both state diagrams, the Moore machine above and the Mealy one, describe exactly the same system. Indeed, automata theory states that you can always translate a Moore machine into a Mealy machine and vice versa, without losing any expressiveness.  


*Harel statecharts*

Although Mealy machines can already reduce the number of required states, for complex systems such automatons get easily unmanageable. Or to put it in David Harel's words:

_“A complex system cannot be beneficially described in this naive fashion, because of the unmanageable, exponentially growing multitude of states, all of which have to be arranged in a ‘flat’ unstratified fashion, resulting in an unstructured, unrealistic, and chaotic state diagram.”_

Harel concluded that "_a state approach must be modular, hierarchical and well-structured"_ and introduced additional concepts like state composition and orthogonality.

He coined the term “statechart”, and defined it as:

_“statecharts = state-diagrams + depth + orthogonality + broadcast communication”_

So basically "Harel statecharts":http://www.wisdom.weizmann.ac.il/~dharel/SCANNED.PAPERS/Statecharts.pdf are Mealy/Moore machines extended by further concepts that allow us to model complex systems in a practical way.

Using composite states and sub diagrams, we are able to bring more *depth* into state diagrams, while keeping the diagrams clear and well-structured. Regions help us to express *orthogonality*: Different substate machines that can be executed side by side. Events allow us to achieve *broadcast communication* and give us a strong means to describe complex behavior. Using guards, we can state that a certain event triggers a transition only if a given condition is met. Inter-level transitions, history states, temporal logic as well as entry, exit and throughout actions are further Harel statechart elements.

To showcase some of these enhancements we extend the light switch example by a motion detection mode. When the _MOT_ button is pressed, the motion sensor is activated. Once the sensor detects any motion (event @motion_detected@), the light is switched on at the highest brightness level (@brightness = 3@).

The corresponding Mealy machine looks like the following:

!(medium)images/overview_mealy_2.png(Extended light switch example as a Mealy machine)!

Because only transitions can produce outputs, many actions need to be duplicated. For example, from each state there is a transition @OFF_pressed / brightness = 0@ to the _Light Off_ state. These redundancies make this rather simple system already harder to read and maintain as necessary.

Harel statecharts combine Mealy and Moore machines, hence outputs can be produced by states and transitions. Furthermore, states can be grouped together to form a hierarchy. As a Harel statechart the light switch example looks like the following:

!(medium)images/overview_harel.png(Extended light switch example as a Harel statechart)!

We can even go one step further and hide the logic of the _Motion Detection Mode_ into a sub diagram. In that way, the system gets more comprehensive as one can directly see the different modes and how to switch between them.

!(medium)images/overview_harel_2.png(Extended light switch example as a Harel statechart with sub diagrams)!

Further concepts like orthogonality, entry/exit actions or history states are left out here for brevity. You can read about them in our "quick reference":../user-guide/quick_ref.html.

*The present age: UML state machines*

UML state machines are based on the statechart notation introduced by David Harel. Furthermore, the UML extends the notation of Harel statecharts by object-oriented principles. Mapping this to our light switch example, in UML we can model the possible actions of the light switch as a type with operations @turnOn()@, @turnOff()@, @setBrightness(value)@ and so on.

The following table illustrates the differences between the previously described types at a glance:

!(large)images/statemachine_types.png(Differences between state machine types)!

p=. Differences between the state machine types

The examples of this article were designed with "YAKINDU Statechart Tools":https://www.itemis.com/en/yakindu/state-machine/, whose documentation you are reading just now.

Learn more about how to model your system with state machines in our free whitepaper:

<a href="https://info.itemis.com/en/yakindu/state-machine/whitepaper/" class="btn btn-warning">Download Whitepaper</a>



h1(#overview_what_are_yakindu_statechart_tools). What are YAKINDU Statechart Tools?

YAKINDU Statechart Tools (YAKINDU SCT) is a modular toolkit for developing, simulating, and generating executable "_finite-state machines (FSM)_":https://en.wikipedia.org/wiki/Finite-state_machine or simply _state machines_.

State machines are useful for the model-driven development of so-called event-discrete systems, i.e., systems that are always in exactly one state of a finite number of states. State machines are particularly well-suited for embedded systems, but they are in no way restricted to them.

With YAKINDU Statechart Tools you can easily develop and simulate state machines, as well as generating them as source code for your target software system. YAKINDU Statechart Tools is based on the open-source development platform Eclipse.

The Standard Edition of YAKINDU Statechart Tools provides the following features for dealing with state machines:

* *Statechart diagram editor* to graphically create and edit statecharts, the graphical representation of state machines
* *Statechart simulator* to simulate the behavior of statecharts
* *Code generators for Java, C, C++ and Python* to transform statecharts into programming language source code
* *Custom generator projects* to easily create model-to-text transformations with Xtend or Java in order to create any code of your own choice
* *Integrated validator* to check for syntactical or semantical problems of the statechart model
* *Testing framework* to test your state machines with unit tests

The following graph shows these features and their relation to each other:

!(large)images/docu_YAKINDU_features.png(Features of YAKINDU Statechart Tools)!

p=. Features of YAKINDU Statechart Tools

The Professional Edition of YAKINDU Statechart Tools makes additional features available:

* "*Deep integration with the C programming language*":../user-guide/c-domain.html#cdom_deep_c_integration to directly access C variables, types etc.
* "*Advanced simulation and debugging*":../user-guide/simulating_statecharts.html#advsim_debugging_with_breakpoints_and_snapshots with breakpoints and snapshots



h2(#overview_which_licensing_rules_do_apply_to_yakindu_statechart_tools). Which licensing rules do apply to YAKINDU Statechart Tools?

###. CHECK Do these licensing information still apply?

Parts of the source code of YAKINDU Statechart Tools are provided under the "Eclipse Public License":http://www.eclipse.org/legal/epl-v10.html.

The code generators coming with YAKINDU Statechart Tools do not imply any license constraints on the generated code whatsoever. The generated code is property of the user, as a person or as an organization. For the generated code, the user is free to choose any license model they wish.




h2(#overview_who_is_behind_yakindu_statechart_tools). Who is behind YAKINDU Statechart Tools?

YAKINDU Statechart Tools is developed and driven by "itemis AG":https://en.wikipedia.org/wiki/Itemis, a well-known consulting company specialized on model-based development. itemis is providing professional services around YAKINDU, be it training or on-site consulting, be it development of prototypes or implementation of full-blown IDEs for programming languages, you name it. The itemis YAKINDU developers do not only know the framework very well but are also experts in programming and domain-specific language design. If you need advice, get in contact with itemis' "YAKINDU team":https://info.itemis.com/contact.




h2(#overview_who_is_using_yakindu_statechart_tools). Who is using YAKINDU Statechart Tools?

Initially YAKINDU Statechart Tools have been designed for the embedded systems industry: automotive, system controls, vending machines etc. However, YAKINDU Statechart Tools are bringing the benefits of finite-state machines (FSM) and Harel statecharts to everyone who needs to design, simulate and develop behavior. People can use YAKINDU Statechart Tools to generate Java, C, C++ or Python code.


